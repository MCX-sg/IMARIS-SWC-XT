"""
Export selected Imaris Filament(s) to SWC.

Author: Mengze Xu(2025)

Usage inside Imaris XT:
  CustomTools -> "Export Filament in SWC format" -> runs XT_export_swc(%i)

Runs inside Imaris' embedded Python 3.x with ImarisLib available on PYTHONPATH.
No Anaconda / external Python environment required.
"""

#<CustomTools>
	#<Menu>
                #<Item name="Export Filament in SWC format" icon="Python3">
                    #<Command>Python3XT::XT_export_swc(%i)</Command>
                #</Item>
       #</Menu>
       #<SurpassTab>
           #<SurpassComponent name="bpFilaments">
               #<Item name="Export Filament in SWC format" icon="Python3">
                   #<Command>Python3XT::XT_export_swc(%i)</Command>
               #</SurpassComponent>
           #</SurpassTab>
#</CustomTools>


from __future__ import annotations
import os, time, datetime
import ImarisLib

SAVE_DIR = os.path.join(os.path.expanduser("~"), "Documents", "ImarisExports")

def _autosave_path(base_name: str, index: int = 0) -> str:
    """
    Create a unique SWC filename in ~/Documents/ImarisExports
    base_name: e.g. 'filament'
    index: 0 for first filament -> "..._1.swc", then _2, _3, ...
    """
    os.makedirs(SAVE_DIR, exist_ok=True)
    stamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    return os.path.join(SAVE_DIR, f"{base_name}_{stamp}_{index+1}.swc")

def _write_swc(path: str, rows: list[tuple]):
    # rows are tuples: (n, type, x, y, z, radius, parent)
    with open(path, "w", encoding="utf-8") as f:
        f.write("# generated by Imaris XT SWC export (no-numpy)\n")
        for n, t, x, y, z, r, p in rows:
            # SWC format: n type x y z radius parent
            f.write(f"{n:d} {t:d} {x:.6f} {y:.6f} {z:.6f} {r:.6f} {p:d}\n")

def XT_export_swc(aImarisId):
    # Connect to Imaris
    vLib = ImarisLib.ImarisLib()
    vImaris = vLib.GetApplication(aImarisId)
    if vImaris is None:
        print("Could not connect to Imaris!")
        time.sleep(2)
        return

    vFactory = vImaris.GetFactory()
    vSelection = vImaris.GetSurpassSelection()
    vFilaments = vFactory.ToFilaments(vSelection)

    if vFilaments is None:
        print("Pick a Filament object in Surpass first.")
        time.sleep(2)
        return

    # dataset scale (pixels per micron in XYZ)
    V = vImaris.GetDataSet()
    # Guard against zero extent
    def _safe_div(a, b): return a / b if (b is not None and b != 0) else 1.0
    px_per_um_x = _safe_div(V.GetSizeX(), (V.GetExtendMaxX() - V.GetExtendMinX()))
    px_per_um_y = _safe_div(V.GetSizeY(), (V.GetExtendMaxY() - V.GetExtendMinY()))
    px_per_um_z = _safe_div(V.GetSizeZ(), (V.GetExtendMaxZ() - V.GetExtendMinZ()))

    # Export each filament as its own SWC file
    count = vFilaments.GetNumberOfFilaments()
    if count == 0:
        print("No filaments found in the selected object.")
        time.sleep(2)
        return

    base_name = "filament"
    for idx in range(count):
        # Fetch data from Imaris
        xyz = vFilaments.GetPositionsXYZ(idx)      # list of (x,y,z) in microns
        edges = vFilaments.GetEdges(idx)           # list of (p1,p2) 0-based indices
        radii = vFilaments.GetRadii(idx)           # list of radii (microns)
        types = vFilaments.GetTypes(idx)           # list of SWC node types (ints)

        N = len(xyz)
        if N == 0:
            continue

        # Build undirected adjacency
        G = [[False]*N for _ in range(N)]
        for p1, p2 in edges:
            if 0 <= p1 < N and 0 <= p2 < N:
                G[p1][p2] = True
                G[p2][p1] = True

        # BFS from node 0 to assign parents in SWC
        visited = [False]*N
        swc_rows: list[tuple] = []
        queue = [0]
        parent_map = {0: -1}  # SWC parent index (1-based in file, -1 for root)
        visited[0] = True

        order = []  # visitation order to map node->swc_id
        while queue:
            cur = queue.pop(0)
            order.append(cur)
            for j in range(N):
                if G[cur][j] and not visited[j]:
                    visited[j] = True
                    parent_map[j] = cur
                    queue.append(j)

        # map original node index -> SWC id (1..N) in visitation order
        node_to_swcid = {node: i+1 for i, node in enumerate(order)}

        # Build SWC rows in visitation order
        for node in order:
            swc_id = node_to_swcid[node]
            p_node = parent_map.get(node, -1)
            parent_id = node_to_swcid[p_node] if p_node in node_to_swcid else -1

            # coordinates: convert microns to "pixel units" if you want to match original script,
            # but most SWC tools expect MICRONS; keep microns here for compatibility.
            x_um, y_um, z_um = xyz[node]
            # If you *really* need pixel units, replace with:
            # x_um *= px_per_um_x; y_um *= px_per_um_y; z_um *= px_per_um_z

            t = int(types[node]) if node < len(types) else 3   # 3 = dendrite (fallback type)
            r = float(radii[node]) if node < len(radii) else 0.5

            swc_rows.append((swc_id, t, float(x_um), float(y_um), float(z_um), r, parent_id))

        # Save file
        out_path = _autosave_path(base_name, idx)
        _write_swc(out_path, swc_rows)
        print(f"Saved: {out_path}")

    print(f"Done. Files are in: {SAVE_DIR}")
    time.sleep(2)